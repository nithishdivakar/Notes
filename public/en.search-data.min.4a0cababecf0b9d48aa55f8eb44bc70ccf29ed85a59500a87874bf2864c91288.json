[{"id":0,"href":"/cp/01a__two-sum/","title":"01a__Two Sum","section":"Cps","content":" Two sum [LC#1] # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\nSorting and two pointers\n$T(n) = O(n \\log n)$; $S(n) = O(n)$ def two_sum(nums: List[int], target:Int) -\u0026gt; Tuple[int, int]: indexed_nums = sorted((n, i) for i, n in enumerate(nums)) left, right = 0, len(indexed_nums) - 1 while left \u0026lt; right: current_sum = indexed_nums[left][0] + indexed_nums[right][0] if current_sum == target: return (indexed_nums[left][1], indexed_nums[right][1]) elif current_sum \u0026lt; target: left += 1 else: right -= 1 return (-1, -1) Hashset\n$T(n) = O(n)$; $S(n) = O(n)$ def two_sum(nums: List[int], target: int) -\u0026gt; Tuple[int, int]: num_to_idx = {} for i, num in enumerate(nums): residue = target - num if residue in lut: return (i, num_to_idx[residue]) num_to_idx[num] = i return (-1, -1) "},{"id":1,"href":"/cp/01c__maximum-subarray-sum/","title":"01c__Maximum Subarray Sum","section":"Cps","content":" Maximum Subarray Sum [LC#53] # Given an integer array nums, find the subarray with the largest sum, and return its sum.\nKadane\u0026rsquo;s algorithm\nFind the max sum of subarray ending at location i. $T(n) = O(n)$; $S(n) = O(1)$ def max_subarray_sum(nums: List[int]) -\u0026gt; int: curr, ans = 0, nums[0] for num in nums: curr = max(curr + num, num) ans = max(ans, curr) return ans "},{"id":2,"href":"/cp/01e__containers-with-most-water/","title":"01e__Containers with Most Water","section":"Cps","content":" Containers with most water [LC#11] # Given $n$ non-negative integers $a_1$, $a_2$, \u0026hellip; , $a_n$ , where each represents a point at coordinate $(i, a_i)$. $n$ vertical lines are drawn such that the two endpoints of the line $i$ is at $(i, a_i)$ and $(i, 0)$. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.\nTwo pointer approach Given 2 walls, the volume of water between them is limited by the smaller one. So we can move inwards from the smaller wall. This can be implemented using a 2 pointer approach closing in from both ends. $T(n) = O(n)$ def max_water(height: List[int]) -\u0026gt; int: left, right = 0, len(height)-1 max_area = 0 while left \u0026lt; right: max_area = max( max_area, (right - left)*(min(height[left], height[right])) ) # we have to move away from the smaller wall # as it is limiting factor of the area if height[left] \u0026lt; height[right]: left += 1 else: right -= 1 return max_area "},{"id":3,"href":"/cp/01f__all-subsets-with-duplicates/","title":"01f__All Subsets with Duplicates","section":"Cps","content":" All Subsets with duplicates [LC#90] # We consider elements with duplicate as 1 element when we need to add this element to subset, we add the on per each frequency def subsets_with_duplicates(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [[],] freq = {} for num in nums: freq[num] = freq.get(num, 0) + 1 for num, freq in freq.items(): curr = [] for subset in ans: for f in range(1, freq+1): new_subset = subset + [num]*f curr.append(new_subset) ans.extend(curr) return ans "},{"id":4,"href":"/cp/01g__median-in-a-stream/","title":"01g__Median in a Stream","section":"Cps","content":"class MedianFinder: def __init__(self): self.low = [] # stores n or n+1 elements self.high = [] # stores n elements def add(self, num: int) -\u0026gt; None: val = heapq.heappushpop(self.low, -num) heapq.heappush(self.high, -val) if len(self.low) \u0026lt; len(self.high): val = heapq.heappop(self.high) heapq.heappush(self.low, -val) def find_median(self) -\u0026gt; float: if len(self.low) \u0026gt; len(self.high): return - self.low[0] return (-self.low[0] + self.high[0])/2 "},{"id":5,"href":"/cp/01h__binary-search/","title":"01h__Binary Search","section":"Cps","content":" I. # Binary search pattern when we are searching for a target # in an ordered array with element w.r.to target like # ┌───────────┬───┬────────────┐ # │ \u0026lt; │ = │ \u0026gt; │ # └───────────┴───┴────────────┘ # L, R = 0, N-1 while L \u0026lt;= R: mid = L + (R-L)//2 if a[mid] == target: return mid if a[mid] \u0026gt; target: R = mid - 1 else: L = mid + 1 return -1 II. # Binary search pattern when we are searching for # the first/smallest valid position when the array is like # ┌───┬───┬───┬───┬───┬───┬───┬───┐ # │ f │ f │ f │ t │ t │ t │ t │ t │ # └───┴───┴───┴───┴───┴───┴───┴───┘ # └── ans # L, R = 0, N-1 ans = -1 while L \u0026lt;= R: mid = L + (R-L)//2 if is_valid(mid): ans = mid R = mid - 1 else: L = mid + 1 return ans "},{"id":6,"href":"/cp/02a__longest-substring-without-repeating-characters/","title":"02a__Longest Substring Without Repeating Characters","section":"Cps","content":" Longest Substring Without Repeating Characters [LC#3] # Given a string s, find the length of the longest substring without repeating characters.\nSliding Window and 2 pointers\nStart with left and right at 0. Expand: Move right to add characters and update counts until a repeat is found. Shrink: Move left to remove characters until all are unique. Track maximum length of the window. $T(n) = O(n)$; $S(n) = O(|char set|)$ def max_substring_without_repetition(s: str) -\u0026gt; int: char_count = defaultdict(int) left = 0 ans = 0 for right in range(len(s)): current_char = s[right] char_count[current_char] += 1 while char_count[current_char]\u0026gt;1: char_count[s[left]] -= 1 left += 1 ans = max(ans, right-left+1) return ans Optimised Sliding window\nSame as previous approach, but keep track last occurance of all characters seen so far. Jump to the next after last occurence whenever a character is encountered again. $T(n) = O(n)$; $S(n) = O(|char set|)$ def max_substring_without_repetition(s: str) -\u0026gt; int: last_found_at = {} left = 0 ans = 0 for right in range(len(s)): current_char = s[right] if current_char in last_found_at: left = max(left, last_found_at[current_char]+1) last_found_at[current_char] = right ans = max(ans, right - left +1) return ans "},{"id":7,"href":"/cp/02d__edit-distances/","title":"02d__Edit Distances","section":"Cps","content":" Edit distance # cost[i][j] = the minimum edit distance (or the minimum number of operations) required to transform the first i characters of word1 into the first j characters of word2. def edit_distance(word1: str, word2: str) -\u0026gt; int: # Define the costs for operations costs = {\u0026#39;insert\u0026#39;: 1, \u0026#39;delete\u0026#39;: 1, \u0026#39;substitute\u0026#39;: 1} m, n = len(word1), len(word2) cost = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column for i in range(m + 1): cost[i][0] = i # Cost of deleting all characters from word1 to form word2 for j in range(n + 1): cost[0][j] = j # Cost of inserting all characters to word1 to form word2 # Fill the cost matrix for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: cost[i][j] = cost[i - 1][j - 1] # No operation needed else: cost[i][j] = min( cost[i - 1][j] + costs[\u0026#39;insert\u0026#39;], # Insert cost[i][j - 1] + costs[\u0026#39;delete\u0026#39;], # Delete cost[i - 1][j - 1] + costs[\u0026#39;substitute\u0026#39;] # Substitute ) return cost[m][n] $T(n) = O(mn)$ $S(n) = O(mn)$ but can be optimised to $O(\\min(m,n))$ "},{"id":8,"href":"/cp/02e01__longest-palindromic-substring/","title":"02e01__Longest Palindromic Substring","section":"Cps","content":" Longest Palindromic Substring # Expand around Center\ndef longestPalindrome(string: str) -\u0026gt; str: def expand_around_center(left: int, right: int, string: str) -\u0026gt; str: while left \u0026gt;= 0 and right \u0026lt; len(string) and string[left] == string[right]: left = left - 1 right = right + 1 return string[left + 1 : right] longest = \u0026#34;\u0026#34; for i in range(len(s)): longest = max( longest, expand_around_center(i, i, string), expand_around_center(i, i + 1, string), key=len, ) return longest $T(n) = O(n^2)$ $S(n) = O(1)$ "},{"id":9,"href":"/cp/02e02__count-palindromic-substrings/","title":"02e02__Count Palindromic Substrings","section":"Cps","content":" Count Palindromic Substrings # def count_palindromic_substrings(s: str) -\u0026gt; int: def expand_around_center(left: int, right: int) -\u0026gt; int: count = 0 while left \u0026gt;= 0 and right \u0026lt; len(s) and s[left] == s[right]: left = left - 1 right = right + 1 count = count + 1 return count count = 0 for i in range(len(s)): # odd length palindromes count += expand_around_center(i, i) # even length palindromes count += expand_around_center(i, i + 1) return count $T(n) = O(n^2)$ $S(n) = O(1)$ "},{"id":10,"href":"/cp/03a__longest-consecutive-sequence/","title":"03a__Longest Consecutive Sequence","section":"Cps","content":" Longest Consecutive Sequence [LC#128] # For each num, if num-1 is not in the list, then its possibly a sequence\u0026rsquo;s begning For each sequence begning, check if conseqtive elements are in the list Each valid sequence is tested once $T(n) = O(n)$ $S(n) = O(n)$ def longestconsecutive_sequence(nums: List[int]) -\u0026gt; int: entries = set(nums) best = 0 for num in nums: if num-1 not in entries: next_num, seq_len = num+1, 1 while next_num in entries: next_num += 1 seq_len += 1 best = max(best, seq_len) return best "},{"id":11,"href":"/cp/03b__longest-increasing-subsequence/","title":"03b__Longest Increasing Subsequence","section":"Cps","content":" Longest Increasing Subsequence # Dynamic programming approach\nFind the length of longest increasing subsequence ending at i. def length_of_lis(nums: List[int]) -\u0026gt; int: if not nums: return 0 max_length = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] \u0026gt; nums[j]: max_length[i] = max(max_length[i], max_length[j] + 1) return max(max_length) Technique based on patience sorting\nIf the number is larger than the largest element in the temporary array, append it. Otherwise, replace the found position with the current number. The length of the temporary array will give the length of the longest increasing subsequence. the tem array may not always have a valid subsequence, but its length will always be equal to longest subsequence. from bisect import bisect_left def length_of_LIS(nums: List[int]) -\u0026gt; int: if not nums: return 0 tails = [] for num in nums: pos = bisect_left(tails, num) if pos == len(tails): tails.append(num) else: tails[pos] = num return len(tails) "},{"id":12,"href":"/cp/03c__longest-common-subsequence/","title":"03c__Longest Common Subsequence","section":"Cps","content":" Longest Common Subsequence # Dynamic programming approach\ndp[i][j] contains length of longest subsequence by using first i-1 characters of first string and j-1 characters of second string. dp[i][0] = 0 and dp[0][j] = 0 $T(n) = O(mn)$; $S(n) = O(mn)$ def longest_common_subsequence(text1: str, text2: str) -\u0026gt; int: m = len(text1) n = len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence is in dp[m][n] return dp[m][n] Dynamic programming approach with space optimisation\n$T(n) = O(mn)$ ; $S(n) = O(\\min\\{m,n\\})$ def longest_common_subsequence(text1: str, text2: str) -\u0026gt; int: if len(text2) \u0026gt; len(text1): return longest_common_subsequence(text2, text1) m = len(text1) n = len(text2) prev = [0] * (n + 1) curr = [0] * (n + 1) for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: curr[j] = prev[j - 1] + 1 else: curr[j] = max(curr[j - 1], prev[j]) prev, curr = curr, prev return prev[n] "},{"id":13,"href":"/cp/04a__merge-intervals/","title":"04a__Merge Intervals","section":"Cps","content":" Merge Intervals [LC#56] # Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nSort and Itrate approach\nSort the intervals by start time Iterate over the intervals one by on merging the current with the previous if there is an overlap $T(n) = O(n log n + n)$; $S(n) = O(n)$ def merge_intervals(intervals: List[List[int]]) -\u0026gt; List[List[int]]: intervals = sorted(intervals) ans = [intervals[0]] for start, end in intervals[1:]: if start \u0026lt;= ans[-1][1]: ans[-1][1] = max(ans[-1][1], end) else: ans.append([start, end]) return ans "},{"id":14,"href":"/cp/04c__min-meeting-rooms/","title":"04c__Min Meeting Rooms","section":"Cps","content":" Min meeting rooms # We are given meeting times in intervals. Find minimum no of meeting rooms required.\nSort all meetings by their start time Keep the ending times of currently occupied meeting rooms in the min heap If current start time is earlier than the min heap end time, we need a new room else we can pop the top and add a new room def min_meeting_rooms(intervals: List[List[int]]) -\u0026gt; int: intervals = sorted(intervals) heap = [intervals[0][1]] # first end time meeting_rooms = 1 for start_time, end_time in intervals[1:]: if start_time \u0026gt;= heap[0]: heapq.heappop(heap) heapq.heappush(heap, end_time) meeting_rooms = max(meeting_rooms, len(heap)) return meeting_rooms $T(n) = O(n log n + n log n)$ sorting + n pops $S(n) = O(n)$ "},{"id":15,"href":"/cp/05a__reversing-a-linked-list/","title":"05a__Reversing a Linked List","section":"Cps","content":" Reversing a linked list iterative # def fn(head): curr = head prev = None while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev "},{"id":16,"href":"/cp/05c__merging-two-sorted-linked-lists/","title":"05c__Merging Two Sorted Linked Lists","section":"Cps","content":" Merge Two Sorted Lists [LC#21] # You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.\n# Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next Iterate and Merge\n$T(n) = O(m+n)$; $S(n) = O(1)$ def merge_two_worted_lists(list1: Optional[ListNode], list2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: fake_head = ListNode() current = fake_head while list1 and list2: if list1.val \u0026lt; list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next current.next = list1 if list1 else list2 return fake_head.next "},{"id":17,"href":"/cp/05e__merge-k-sorted-lists/","title":"05e__Merge K Sorted Lists","section":"Cps","content":" Merge k Sorted Lists [LC#23] # You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\nBrute-Force\nMerge all lists into one and sort the list $T(n) = O(n log n)$ ; $S(n) = O(n)$ Priority Queue or Min Heap\nCreate a min heap with first values of all the lists Repeatedly pop the root of min heap, add to the answer and push the next value of the list where root was from to the heap $T(n) = O(k + n log k)$ heapify + n pop root $S(n) = O(k)$ for the heap def merge_sorted_lists(lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: class HeapNode: def __init__(self, node: ListNode): self.node = node def __lt__(self, other): return self.node.val \u0026lt; other.node.val heap = [] current = dummy = ListNode(0) for lst in lists: if lst: heapq.heappush(heap, HeapNode(lst)) while heap: node = heapq.heappop(heap).node current.next = node current = current.next if node.next: heapq.heappush(heap, HeapNode(node.next)) return dummy.next Iterative Mergesort on sorted lists\nTake 2 pairs of list and sort them together Do this iteratively until there is only 1 left $T(n) = O(n + n/2 + n/4 + \u0026hellip; +n/k) = O(n log k)$ $S(n) = O(1)$ "},{"id":18,"href":"/cp/05f__detecting-a-cycle-in-linked-list/","title":"05f__Detecting a Cycle in Linked List","section":"Cps","content":" Cycle detection # Turtle and hare algorithm It relies on the fact that if two pointers are moving at different speeds within a cycle, their distances will reach a max length before being reset to zero at which point they will point to the same element. $T(n) = O(n)$ Will travel initial n of non-cyclic then k which is cycle length. $S(n) = O(n)$ def has_cycle(head: Optional[ListNode]) -\u0026gt; bool: turtle, hare = ListNode(0, head), ListNode(0, head) while turtle and hare: if turtle == hare: return True turtle = turtle.next hare = hare.next.next if hare.next else None return False "},{"id":19,"href":"/cp/06a05__binary-tree-from-its-traversals/","title":"06a05__Binary Tree from its Traversals","section":"Cps","content":" Construct a binary tree from its in and pre prder traversals # def build_tree(self, preorder: List[int], inorder: List[int]) -\u0026gt; Optional[TreeNode]: val_to_idx = {val: idx for idx, val in enumerate(inorder)} def construct(in_left, in_right): if in_left \u0026gt; in_right: return None val = preorder.pop(0) in_idx = val_to_idx[val] node = TreeNode(val) node.left = construct(in_left, in_idx - 1) node.right = construct(in_idx + 1, in_right) return node return construct(0, len(preorder) - 1) "},{"id":20,"href":"/cp/06b__binary-tree-maximum-path-sum/","title":"06b__Binary Tree Maximum Path Sum","section":"Cps","content":" Binary Tree Maximum Path Sum [LC#124] # A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node\u0026rsquo;s values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\nThe answer is inspired from from Kadane\u0026rsquo;s algorithm for max array sum At every node, we are looking for what is max path sum of the path ending at the node and containing only the node\u0026rsquo;s children. On e we have that for both children, we can also calculate the max path sum of the path passing through the node. Keep track of the maximum of such path sum\u0026rsquo;s $T(n) = O(n)$; $S(n) = O(1)$ def binary_tree_max_path_sum(root: Optional[TreeNode]) -\u0026gt; int: ans = float(\u0026#39;-inf\u0026#39;) def ending_with(node): # What is the max path sum with path ending at node # and the path contains only node\u0026#39;s children? nonlocal ans if not node: return 0 left_gain = max(ending_with(node.left), 0) right_gain = max(ending_with(node.right), 0) node_gain = max(left_gain, left_gain) + node.val # max path sum of path passing through node current_max = left_gain + node.val + right_gain ans = max(ans, current_max) return node_gain ending_with(root) return ans "},{"id":21,"href":"/cp/06c01__in-a-binary-tree/","title":"06c01__In a Binary Tree","section":"Cps","content":" LCA In Binary Tree # class Node: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: \u0026#34;Node\u0026#34;, p: \u0026#34;Node\u0026#34;, q: \u0026#34;Node\u0026#34;) -\u0026gt; \u0026#34;Node\u0026#34;: def search(node): if node in [p, q, None]: return node left = search(node.left) right = search(node.right) if left and right: return node return left if left else right return search(root) "},{"id":22,"href":"/cp/07c01__bfs-like-topological-sort-kahn-algorithm/","title":"07c01__BFS like Topological Sort (Kahn Algorithm)","section":"Cps","content":" Kahn\u0026rsquo;s Algorithm (BFS-like) # def topological_sort_kahn(graph: Dict[str, List[str]]) -\u0026gt; List[str]: in_degree = {u: 0 for u in graph} # Initialize in-degrees to 0 for u in graph: for v in graph[u]: in_degree[v] += 1 # Increment in-degree for each edge queue = deque([u for u in in_degree if in_degree[u] == 0]) topological_order = [] while queue: u = queue.popleft() # Get a vertex with in-degree 0 topological_order.append(u) # Add it to the topological order for v in graph[u]: in_degree[v] -= 1 # Remove the edge u -\u0026gt; v if in_degree[v] == 0: # If in-degree becomes 0, add to queue queue.append(v) if len(topological_order) != len(graph): return [] return topological_order Example Graph\ngraph = { \u0026#39;A\u0026#39;: [\u0026#39;C\u0026#39;], \u0026#39;B\u0026#39;: [\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;], \u0026#39;C\u0026#39;: [\u0026#39;E\u0026#39;], \u0026#39;D\u0026#39;: [\u0026#39;E\u0026#39;], \u0026#39;E\u0026#39;: [] } "},{"id":23,"href":"/cp/07c02__dfs-like-topological-sort/","title":"07c02__DFS like Topological Sort","section":"Cps","content":" DFS like topological sort # def topological_sort_dfs(graph: Dict[str, List[str]]) -\u0026gt; List[str]: WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} stack: List[str] = [] def dfs(node: str) -\u0026gt; bool: if color[node] == GRAY: return [] # Cycle detected if color[node] == WHITE: color[node] = GRAY for neighbor in graph[node]: if not dfs(neighbor): # cycle in recursion return False color[node] = BLACK stack.append(node) return True for vertex in graph: if color[vertex] == WHITE: if not dfs(vertex): # If a cycle is detected return [] return stack[::-1] "},{"id":24,"href":"/cp/07e01__dijkstra-algorithm/","title":"07e01__Dijkstra Algorithm","section":"Cps","content":" Dijkstra algorithm # graph = {u : [(v, w(u,v)), ..], ... } def dijkstra(graph: List[List[Tuple[int, float]]], source: int) -\u0026gt; List[float]: n = len(graph) distances: List[float] = [math.inf] * n distances[source] = 0.0 heap: List[Tuple[float, int]] = [(0.0, source)] while heap: curr_dist, node = heapq.heappop(heap) if curr_dist \u0026gt; distances[node]: continue for neighbour, weight in graph[node]: dist = curr_dist + weight if dist \u0026lt; distances[neighbour]: distances[neighbour] = dist heapq.heappush(heap, (dist, neighbour)) return distances $T(n) = O( (V+E) \\log V)$ $O(V \\log{V})$: Extract the minimum node from the heap for each vertex. $O(E \\log{V})$: Time taken to insert or update distances for each edge. $S(n) = O(V)$ "},{"id":25,"href":"/cp/07e02__bellman-ford-algorithm/","title":"07e02__Bellman-Ford Algorithm","section":"Cps","content":" Bellman-Ford # def bellman_ford(graph, source): # Initialize distances from source to all vertices as INFINITE distances = {v: float(\u0026#34;inf\u0026#34;) for v in graph} distances[source] = 0 # Distance from source to itself is always 0 # Relax all edges |V| - 1 times for _ in range(len(graph) - 1): for u in graph: for v, w in graph[u]: if distances[u] != float(\u0026#34;inf\u0026#34;) and distances[u] + w \u0026lt; distances[v]: distances[v] = distances[u] + w # Check for negative-weight cycles for u in graph: for v, w in graph[u]: if distances[u] != float(\u0026#34;inf\u0026#34;) and distances[u] + w \u0026lt; distances[v]: print(\u0026#34;Graph contains negative weight cycle\u0026#34;) return None return distances "},{"id":26,"href":"/cp/08__sets/","title":"08__Sets","section":"Cps","content":" Subsets II [LC#90] # Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\n$T(n) = O(2^n)$; $S(n) = O(2^n)$ def subsets_of_multiset(nums: List[int]) -\u0026gt; List[List[int]]: powerset = [[],] freq = {} for num in nums: freq[num] = freq.get(num, 0)+1 for num, num_freq in freq.items(): curr = [] for subset in ans: for ff in range(1, num_freq + 1): new_subset = subset + [num] * ff curr.append(new_subset) powerset.extend(curr) return powerset "},{"id":27,"href":"/cp/08a__dsu-union-find/","title":"08a__DSU Union-Find","section":"Cps","content":"class DSU: def __init__(self): self.parent = {} self.rank = {} def find(self, x): if x not in self.parent: # new node self.parent[x] = x self.rank[x] = 0 if self.parent[x] != x: # path compression self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): root_x = self.find(x) root_y = self.find(y) if root_x != root_y: if self.rank[root_x] \u0026lt; self.rank[root_y]: root_x, root_y = root_y, root_x self.parent[root_y] = root_x if self.rank[root_x] == self.rank[root_y]: self.rank[root_x] += 1 return True return False "},{"id":28,"href":"/cp/08b__dsu-with-rollbacks/","title":"08b__DSU with Rollbacks","section":"Cps","content":" We do not add path compression as addition of roll back will results in unnecessary operations. This results in O(log n) for find (due to merge by rank) class DSU_rollback: def __init__(self): self.parent = {} self.rank = {} self.history = [] def find(self, v): if v not in self.parent: self.parent[v] = v self.rank[v] = 0 if v == self.parent[v]: return v # self.parent[v] = self.find(self.parent[v]) # We don\u0026#39;t perform path compression return self.find(self.parent[v]) def union(self, v, u): v = self.find(v) u = self.find(u) if v == u: return False if self.rank[v] \u0026gt; self.rank[u]: v, u = u, v self.history.append((v, self.rank[v], u, self.rank[u])) self.parent[v] = u if self.rank[v] == self.rank[u]: self.rank[u] += 1 return True def rollback(self): if not self.history: return v, rank_v, u, rank_u = self.history.pop() self.parent[v] = v self.rank[v] = rank_v self.parent[u] = u self.rank[u] = rank_u "},{"id":29,"href":"/cp/09d__subsetsum-to-knapsack/","title":"09d__subsetsum to knapsack","section":"Cps","content":" Reducing subset sum to 0/1 knapsack # def subset_sum(nums: List[int], target: int) -\u0026gt; bool: max_value = knapsack_01(nums, nums, target) return max_value == target def knapsack_01(weights: List[int], values: List[int], capacity: int) -\u0026gt; int: max_value = [0] * (capacity + 1) for weight, value in zip(weights, values): for slack in range(capacity, weight - 1, -1): max_value[slack] = max(max_value[slack], max_value[slack - weight] + value) return max_value[capacity] "},{"id":30,"href":"/cp/tracker/","title":"index","section":"Cps","content":" 01__Arrays 01a__Two Sum 01b__Three Sum 01c__Maximum Subarray Sum 01d__Duplicate Number 01e__Containers with Most Water 01f__All Subsets with Duplicates 01g__Median in a Stream 01h__Binary Search 01h03__Find Minimum in Rotated Sorted Array 02__Strings 02a__Substring without Repetitions 02b__Longest Common Prefix 02c__Group Anagrams 02d__Edit Distances 02e__Palindromes 02e01__Longest Palindromic Substring 02e02__Count Palindromic Substrings 02e03__Palindromic Partition 03__Sequences 03a__Longest Consecutive Sequence 03b__Longest Increasing Subsequence 03c__Longest Common Subsequence 03d__Longest Palindromic Subsequence 04__Intervals 04a__Merge Intervals 04b__Insert Interval 04c__Min Meeting Rooms 05__Linked List 05a__Reversing a Linked List 05b__Remove Nth Node From End of List [s] 05c__Merging Two Sorted Linked Lists 05e__Merge K Sorted Lists 05f__Detecting a Cycle in Linked List 05g__Implementing LRU Cache 06__Trees 06a__Tree Traversals 06a01__In Order 06a02__Pre Order 06a03__Post Order 06a04__Level Order 06a05__Binary Tree from its Traversals 06b__Binary Tree Maximum Path Sum 06c__Lowest Common Ancestor 06c01__In a Binary Tree 06c02__In a Binary Search Tree 07__Graphs 07a__BFS 07b__DFS 07c__Topological Sort 07c01__BFS like Topological Sort (Kahn Algorithm) 07c02__DFS like Topological Sort 07d__Connected Components 07e__Single Source Shortest Path 07e01__Dijkstra Algorithm 07e02__Bellman-Ford Algorithm 07f__Minimum Spanning Tree 07g__Max Flow Min Cut 08__Sets 08a__DSU Union-Find 08b__DSU with Rollbacks 09__Knapsack 09a__0/1 Knapsack Problem 09b__Unbounded Knapsack 09c__Fractional Knapsack Problem 10__Backtracking 10a__N-Queens Problem 10b__Sudoku Solver 10c__Permutations 11__Greedy Approach matrix chain multiplication\n"}]