<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>07c01__BFS like Topological Sort (Kahn Algorithm) | Notes</title><meta name="description" content="while True: continue"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/notes/07c01__BFS%20like%20Topological%20Sort%20(Kahn%20Algorithm)/"><link rel="stylesheet" href="/assets/style.css"><body><main> <!--<h2 class="title">Notes</h2>--><nav> <a href="http://localhost:4000">Notes</a> <a href="http://localhost:4000">Home</a> <!-- <a href="http://localhost:4000/assets/resume.pdf">Resume</a> <a href="http://localhost:4000dd">RRR</a> <a href="https://duckduckgo.com">[Search]</a> --></nav><!--<h1>07c01__BFS like Topological Sort (Kahn Algorithm)</h1><i>Jan 01, 2024</i><h4 class="subtitle"></h4>--><h2 id="kahns-algorithm-bfs-like">Kahn’s Algorithm (BFS-like)</h2><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">topological_sort_kahn</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="n">in_degree</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>  <span class="c1"># Initialize in-degrees to 0
</span>    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment in-degree for each edge
</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">topological_order</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>  <span class="c1"># Get a vertex with in-degree 0
</span>        <span class="n">topological_order</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># Add it to the topological order
</span>        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Remove the edge u -&gt; v
</span>            <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If in-degree becomes 0, add to queue
</span>                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">topological_order</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">len</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">topological_order</span>
</code></pre></div></div><p><strong>Example Graph</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['E'],
    'E': []
}
</code></pre></div></div></main><footer> <a href="/">← Back to all notes</a></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
